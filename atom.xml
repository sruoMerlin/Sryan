<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>如切如磋，如琢如磨</title>
  
  
  <link href="https://sruomerlin.github.io/atom.xml" rel="self"/>
  
  <link href="https://sruomerlin.github.io/"/>
  <updated>2021-01-18T10:23:13.952Z</updated>
  <id>https://sruomerlin.github.io/</id>
  
  <author>
    <name>SruoMerlin</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>动态规划（二）</title>
    <link href="https://sruomerlin.github.io/2021/01/18/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%88%E4%BA%8C%EF%BC%89/index.html"/>
    <id>https://sruomerlin.github.io/2021/01/18/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%88%E4%BA%8C%EF%BC%89/index.html</id>
    <published>2021-01-18T10:22:19.000Z</published>
    <updated>2021-01-18T10:23:13.952Z</updated>
    
    <content type="html"><![CDATA[<h3 id="打家劫舍（一）"><a href="#打家劫舍（一）" class="headerlink" title="打家劫舍（一）"></a>打家劫舍（一）</h3><h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><ul><li>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，<strong>如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。</strong></li><li>给定一个代表每个房屋存放金额的非负整数数组，计算你 <strong>不触动警报装置的情况下</strong> ，一夜之内能够偷窃到的<strong>最高</strong>金额。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">示例1：</span><br><span class="line">输入：[1,2,3,1]</span><br><span class="line">输出：4</span><br><span class="line">解释：偷窃 1 号房屋 (金额 &#x3D; 1) ，然后偷窃 3 号房屋 (金额 &#x3D; 3)。 偷窃到的最高金额 &#x3D; 1 + 3 &#x3D; 4 。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">示例2：</span><br><span class="line">输入：[2,7,9,3,1]</span><br><span class="line">输出：12</span><br><span class="line">解释：偷窃 1 号房屋 (金额 &#x3D; 2), 偷窃 3 号房屋 (金额 &#x3D; 9)，接着偷窃 5 号房屋 (金额 &#x3D; 1)。</span><br><span class="line">偷窃到的最高金额 &#x3D; 2 + 9 + 1 &#x3D; 12 。</span><br></pre></td></tr></table></figure><h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4></li></ul><p><strong>状态转移方程</strong></p><ul><li>假设一排房屋rooms（房间数&gt;2），从最右侧开始考虑，对于第i+1间房屋rooms[i]只有两种状态：<ol><li>偷窃：最近的下一间可偷窃的房间就是[i-2]，已获得金额rooms[i]<ul><li>最终获得金额：f(i-2) + rooms[i] </li></ul></li><li>不偷窃：最近的下一间可偷窃的房间就是[i-1]，已获得金额0<ul><li>最终获得金额：f(i-1) + 0 </li></ul></li></ol></li><li>所以最终能得到的最高金额就是：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">result &#x3D; Max((f(i-2) + rooms[i]),f(i-1))</span><br></pre></td></tr></table></figure></li></ul><p><strong>考虑边界值</strong></p><ul><li>房屋数为0： result = 0;</li><li>房屋数为1： result = rooms[0];</li></ul><p><strong>输出</strong></p><ul><li>判断输出是否为最终状态；</li></ul><p><strong>代码</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line"></span><br><span class="line">public static HashMap&lt;Integer, Integer&gt; cache &#x3D; new HashMap&lt;&gt;();</span><br><span class="line">public static int rob(int[] rooms) &#123;</span><br><span class="line">cache.clear();</span><br><span class="line">return fCore(rooms, rooms.length - 1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static int fCore(int[] rooms, int index) &#123;</span><br><span class="line">  if (index &lt; 0) &#123;</span><br><span class="line">    return 0;</span><br><span class="line">  &#125;</span><br><span class="line">  if (index &#x3D;&#x3D; 0) &#123;</span><br><span class="line">    return rooms[0];</span><br><span class="line">  &#125;</span><br><span class="line">  if (cache.containsKey(index)) &#123;</span><br><span class="line">    return cache.get(index);</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  int count &#x3D; Math.max(fCore(rooms, index - 1), fCore(rooms, index - 2) + rooms[index]);</span><br><span class="line">  cache.put(index, count);</span><br><span class="line">  return count;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="打家劫舍（二）"><a href="#打家劫舍（二）" class="headerlink" title="打家劫舍（二）"></a>打家劫舍（二）</h3><h4 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h4><ul><li>你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都 围成一圈， 这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警 。</li><li>给定一个代表每个房屋存放金额的非负整数数组，计算你在不触动警报装置的情况下 ，能够偷窃到的最高金额。</li></ul><h4 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h4><ul><li>状态转移方程和基本思路同打家劫舍（一），</li><li>环状排列意味着第一个房子和最后一个房子中只能选择一个偷窃，因此可以把此环状排列房间问题约化为两个单排排列房间子问题：<ol><li>在不偷窃第一个房子的情况下（rooms[1 ~ n]），最大金额是P1;</li><li>在不偷窃最后一个房子的情况下（rooms[0 ~ (n-1)]），最大金额是P2。</li></ol></li><li>比较两者较大值max(p1, p2) </li></ul><p><strong>代码</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public static HashMap&lt;Integer, Integer&gt; cache &#x3D; new HashMap&lt;&gt;();</span><br><span class="line">    public int rob(int[] nums) &#123;</span><br><span class="line">        if(nums.length &#x3D;&#x3D; 1) return nums[0];</span><br><span class="line">        cache.clear();</span><br><span class="line">        int max1 &#x3D; myRob(Arrays.copyOfRange(nums, 0, nums.length - 1), nums.length-2);</span><br><span class="line">        cache.clear();</span><br><span class="line">        int max2 &#x3D; myRob(Arrays.copyOfRange(nums, 1, nums.length), nums.length-2);</span><br><span class="line">        return Math.max(max1, max2);</span><br><span class="line">    &#125;</span><br><span class="line">    private int myRob(int[] rooms, int index) &#123;</span><br><span class="line">        if (index &lt; 0) &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    if (index &#x3D;&#x3D; 0) &#123;</span><br><span class="line">        return rooms[0];</span><br><span class="line">    &#125;</span><br><span class="line">    if (cache.containsKey(index)) &#123;</span><br><span class="line">        return cache.get(index);</span><br><span class="line">    &#125;</span><br><span class="line">    int count &#x3D; Math.max( myRob(rooms, index - 1),  myRob(rooms, index - 2) + rooms[index]);</span><br><span class="line">    cache.put(index, count);</span><br><span class="line">    return count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;打家劫舍（一）&quot;&gt;&lt;a href=&quot;#打家劫舍（一）&quot; class=&quot;headerlink&quot; title=&quot;打家劫舍（一）&quot;&gt;&lt;/a&gt;打家劫舍（一）&lt;/h3&gt;&lt;h4 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>动态规划（一）</title>
    <link href="https://sruomerlin.github.io/2021/01/18/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%88%E4%B8%80%EF%BC%89/index.html"/>
    <id>https://sruomerlin.github.io/2021/01/18/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%88%E4%B8%80%EF%BC%89/index.html</id>
    <published>2021-01-18T07:06:01.000Z</published>
    <updated>2021-01-18T10:25:16.727Z</updated>
    
    <content type="html"><![CDATA[<h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h3><p>Those who do not remember the past are condemned to repeat it.</p><h4 id="理论"><a href="#理论" class="headerlink" title="理论"></a>理论</h4><ul><li>特点<ul><li>重复子问题：需要记录之前的计算结果；</li><li>最优子结构：不同规模之间的关系；</li><li>后无效性：只记录阶段结果而不关心这个结果是怎么来的；</li></ul></li><li>思路方向<ul><li>自顶向下：递归+记忆化；</li><li>自底向上：递推求解。</li></ul></li><li>状态转移方程<ul><li>将当前问题分解为几个小问题，这些小问题的最优解构成当前问题的最优解；  </li></ul></li><li>初始化</li><li>输出<ul><li>有时题目的解并不是最后一个状态</li></ul></li><li>考虑是否有可优化空间</li></ul><h4 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h4><h5 id="最长回文子串"><a href="#最长回文子串" class="headerlink" title="最长回文子串"></a>最长回文子串</h5><p>题目：<br>给你一个字符串 s，找到 s 中最长的回文子串。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：s &#x3D; &quot;babad&quot;</span><br><span class="line">输出：&quot;bab&quot;</span><br><span class="line">解释：&quot;aba&quot; 同样是符合题意的答案。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">示例 2：</span><br><span class="line">输入：s &#x3D; &quot;accacc&quot;</span><br><span class="line">输出：&quot;ccacc&quot;</span><br></pre></td></tr></table></figure><p>解题思路：</p><p><strong>状态转移方程</strong></p><ul><li>对于一个长度大于2的子串而言，如果他是回文串，那么它的首尾字符相同且去掉首尾两个字符，它任然是个回文串。</li><li>使用f(i, j)表示字符串s从第i个字符到第j个字符所组成的字符串 ，f(i, j)是回文串等价 于 f(i + 1, j - 1)是回文串且s[i] 和 s[j]相等。 根据这样的思路可以得出他的状态转移方程：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f(i,j) &#x3D; f(i + 1, j - 1) ∧ (s[i]&#x3D;&#x3D; s[j])</span><br></pre></td></tr></table></figure></li></ul><p><strong>初始化</strong></p><ul><li>对于长度大于3的状态可以使用状态转移方程，对于长度为1的字符串，它肯定是一个回文串；对于长度为2的字符串，当两个字符相同即s[i] = s[i+1]时，它是一个回文串，所以可得出初始化：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">f(i, i) &#x3D; true</span><br><span class="line"></span><br><span class="line">f(i, i+1) &#x3D; (s[i] &#x3D;&#x3D; s[i + 1])</span><br></pre></td></tr></table></figure></li></ul><p><strong>思考输出</strong></p><ul><li>我们需要求出的结果是最长回文串，是整个计算过程中的某一个状态，并不一定是是递归到最后一层所得出的结果。</li><li>设置maxLength = 0， 每当计算出一个状态且子串长度大于maxLength时更新maxLength的值并记录子串。</li></ul><p><strong>代码</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public String longestPalindrome(String s) &#123;</span><br><span class="line">    int maxLength &#x3D; 0;</span><br><span class="line">    String result &#x3D; &quot;&quot;;</span><br><span class="line">    boolean[][] dp &#x3D; new boolean[s.length()][s.length()];</span><br><span class="line">    for (int j &#x3D; 0; j &lt; s.length(); ++j) &#123;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; j + 1; ++i) &#123;</span><br><span class="line">            if (i &#x3D;&#x3D; j) &#123;</span><br><span class="line">                dp[i][j] &#x3D; true;</span><br><span class="line">            &#125; else if (j - i &#x3D;&#x3D; 1) &#123;</span><br><span class="line">                dp[i][j] &#x3D; (s.charAt(i) &#x3D;&#x3D; s.charAt(j));</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                dp[i][j] &#x3D; dp[i + 1][j - 1] &amp;&amp; (s.charAt(i) &#x3D;&#x3D; s.charAt(j));</span><br><span class="line">            &#125;</span><br><span class="line">            if (dp[i][j] &amp;&amp; j - i + 1 &gt; maxLength) &#123;</span><br><span class="line">                maxLength &#x3D; j - i + 1;</span><br><span class="line">                result &#x3D; s.substring(i, j + 1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong>：二维 dp 问题，一个状态得用二维有序数对表示。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">时间复杂度：O(N^&#123;2&#125;)</span><br><span class="line"></span><br><span class="line">空间复杂度：O(N^&#123;2&#125;)</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;动态规划&quot;&gt;&lt;a href=&quot;#动态规划&quot; class=&quot;headerlink&quot; title=&quot;动态规划&quot;&gt;&lt;/a&gt;动态规划&lt;/h3&gt;&lt;p&gt;Those who do not remember the past are condemned to repeat it.</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>learn-hexo</title>
    <link href="https://sruomerlin.github.io/2021/01/13/learn-hexo/index.html"/>
    <id>https://sruomerlin.github.io/2021/01/13/learn-hexo/index.html</id>
    <published>2021-01-13T09:57:23.000Z</published>
    <updated>2021-01-13T09:57:23.352Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://sruomerlin.github.io/2021/01/13/hello-world/index.html"/>
    <id>https://sruomerlin.github.io/2021/01/13/hello-world/index.html</id>
    <published>2021-01-13T02:58:07.817Z</published>
    <updated>2021-01-13T02:58:07.817Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</summary>
      
    
    
    
    
  </entry>
  
</feed>
