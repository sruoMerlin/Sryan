<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>如切如磋，如琢如磨</title>
  
  
  <link href="https://sruomerlin.github.io/atom.xml" rel="self"/>
  
  <link href="https://sruomerlin.github.io/"/>
  <updated>2021-01-27T13:00:35.690Z</updated>
  <id>https://sruomerlin.github.io/</id>
  
  <author>
    <name>SruoMerlin</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>java学习（一）</title>
    <link href="https://sruomerlin.github.io/2021/01/26/java-%E5%AD%A6%E4%B9%A0/index.html"/>
    <id>https://sruomerlin.github.io/2021/01/26/java-%E5%AD%A6%E4%B9%A0/index.html</id>
    <published>2021-01-26T10:59:17.000Z</published>
    <updated>2021-01-27T13:00:35.690Z</updated>
    
    <content type="html"><![CDATA[<h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><h2 id="字符串的常用方法"><a href="#字符串的常用方法" class="headerlink" title="字符串的常用方法"></a>字符串的常用方法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String str;</span><br></pre></td></tr></table></figure><ol><li>去掉左右多余空格<br><code>str.trim()</code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">str.trim();</span><br><span class="line">&#x2F;&#x2F; 方法执行后得到一个新的字符串，这个新的字符串左右没有空格</span><br></pre></td></tr></table></figure></li><li>查找字符串 <code>indexOf()</code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">str.indexOf(String string);</span><br><span class="line">&#x2F;&#x2F; 返回文本中第一个匹配到索引值，return -1说明不匹配</span><br><span class="line">str.indexOf(String string, int start)</span><br><span class="line">&#x2F;&#x2F; 从start位置开始查找</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String str &#x3D; &quot;sdfsd java sdfdsfsdf java fsdfsdf java&quot;;</span><br><span class="line">int index &#x3D; str.indexOf(&quot;java&quot;);</span><br><span class="line">int result &#x3D; str.indexOf(&quot;java&quot;, index + 4);</span><br><span class="line">&#x2F;&#x2F; 查找第二个要查找的字符串；</span><br></pre></td></tr></table></figure></li><li>字符串截取 <code>substring()</code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">str.substring(int start);</span><br><span class="line">&#x2F;&#x2F; 从start索引（含start） -&gt; 字符串结束</span><br><span class="line"></span><br><span class="line">str.substring(int start, int end);</span><br><span class="line">&#x2F;&#x2F; 从start索引（含start） -&gt; end索引（不含end）</span><br></pre></td></tr></table></figure></li><li>字符串开始和结束内容判断 <code>startsWith()/endsWith()</code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String file &#x3D; &quot;test.doc&quot;;</span><br><span class="line">file.endsWith(&quot;.doc&quot;);</span><br><span class="line"></span><br><span class="line">String url &#x3D; &quot;https:&#x2F;&#x2F;www.kkkkkk.com&quot;</span><br><span class="line">url.startsWith(&quot;https&quot;);</span><br></pre></td></tr></table></figure></li><li>字符串替换 <code>replaceAll()</code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">replace(String oldData, String newData);</span><br></pre></td></tr></table></figure></li><li>字符串分割<code>split()</code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">str.split(String string)</span><br><span class="line">&#x2F;&#x2F; 以string为界分割字符串为数组（返回字符串数组）</span><br><span class="line">&#x2F;&#x2F; 注意，分隔符为| * ^ : . 需要转义</span><br><span class="line">&#x2F;&#x2F; eg. str.split(&quot;\\|&quot;);</span><br></pre></td></tr></table></figure></li><li>大小写转换<code>toUpperCase()/toLowerCase()</code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">str.toUpperCase() &#x2F;&#x2F; 全部变为大写</span><br><span class="line">str.toLowerCase() &#x2F;&#x2F; 全部变为小写</span><br></pre></td></tr></table></figure></li><li>字符串比较<code>equals()</code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">str.equals(String string);</span><br><span class="line">&#x2F;&#x2F; 比较两个字符串 str 和 string 是否相同</span><br></pre></td></tr></table></figure></li><li>数字和字符串转换<code>Integer.parseInt()</code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int num &#x3D; Integer.parseInt(&quot;12138&quot;);</span><br><span class="line">&#x2F;&#x2F; 字符串转换为数字</span><br><span class="line">String string &#x3D; String.valueOf(100);</span><br><span class="line">&#x2F;&#x2F; 数字转换为字符串，valueOf()可以将数字、浮点、布尔类型转换为字符串</span><br><span class="line">&#x2F;&#x2F; 也可以使用 &quot;+&quot; 拼接字符串自动转换数字为字符串</span><br></pre></td></tr></table></figure><h1 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h1><h2 id="日期类型"><a href="#日期类型" class="headerlink" title="日期类型"></a>日期类型</h2></li></ol><ul><li><code>String、int、double、long</code>这些属于基础类型，不需要导入包，日期类型<code>LocalDate</code>（java8版本推出）需<code>import java.time.LocalDate</code></li><li>now() 返回当前程序所在计算机的系统时间<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import java.time.LocalDate;</span><br><span class="line"></span><br><span class="line">public class DateTest &#123;</span><br><span class="line">    public static void main (String[] args) &#123;</span><br><span class="line">        LocalDate now &#x3D; LocalDate.now();</span><br><span class="line">        System.out.println(time.toString());</span><br><span class="line">        &#x2F;&#x2F; 2021-01-27</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="日期时间和字符串的转化"><a href="#日期时间和字符串的转化" class="headerlink" title="日期时间和字符串的转化"></a>日期时间和字符串的转化</h3></li><li><code>yy-MM-dd</code>字母是固定的，字母之外的字符可以更换<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">import java.time.LocalDate;</span><br><span class="line">import java.time.format.DateTimeFormatter;</span><br><span class="line"></span><br><span class="line">public class DateTest5 &#123;</span><br><span class="line"></span><br><span class="line">  public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">    LocalDate time &#x3D; LocalDate.now();</span><br><span class="line">    System.out.println(time.toString());</span><br><span class="line">    &#x2F;* 2021-01-27 *&#x2F;</span><br><span class="line"></span><br><span class="line">    &#x2F;* 创建一个格式化方式 *&#x2F;</span><br><span class="line">    DateTimeFormatter df &#x3D; DateTimeFormatter.ofPattern(&quot;yyyy年MM月dd日&quot;);</span><br><span class="line">    String timeStr &#x3D; df.format(time);</span><br><span class="line">    System.out.println(timeStr);</span><br><span class="line">    &#x2F;* 2021年01月27日 *&#x2F;</span><br><span class="line">    </span><br><span class="line">    df &#x3D; DateTimeFormatter.ofPattern(&quot;yyyy&#x2F;MM&#x2F;dd&quot;);</span><br><span class="line">    timeStr &#x3D; df.format(time);</span><br><span class="line">    System.out.println(timeStr);</span><br><span class="line">    &#x2F;* 2021&#x2F;01&#x2F;27 *&#x2F;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="获得日期具体值"><a href="#获得日期具体值" class="headerlink" title="获得日期具体值"></a>获得日期具体值</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">import java.time.LocalDate;</span><br><span class="line"></span><br><span class="line">public class DateTest7 &#123;</span><br><span class="line"></span><br><span class="line">  public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">    LocalDate time &#x3D; LocalDate.now();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 得到当前时间所在年</span><br><span class="line">    int year &#x3D; time.getYear();</span><br><span class="line">    System.out.println(&quot;当前年份 &quot; + year);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 得到当前时间所在月</span><br><span class="line">    int month &#x3D; time.getMonth().getValue();</span><br><span class="line">    System.out.println(&quot;当前月份 &quot; + month);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 得到当前时间所在日</span><br><span class="line">    int day &#x3D; time.getDayOfMonth();</span><br><span class="line">    System.out.println(&quot;当前日 &quot; + day);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 得到当前时间所在星期数</span><br><span class="line">    int dayOfWeek &#x3D; time.getDayOfWeek().getValue();</span><br><span class="line">    System.out.println(&quot;当前星期 &quot; + dayOfWeek);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>关于<code>getValue()</code>:<ul><li><code>getMonth()</code>和<code>getDayOfWeek()</code>方法的返回值不是具体的数字，而是一个对象，所以必须使用<code>getValue()</code>得到具体的数字。<h2 id="时间日期类的运用"><a href="#时间日期类的运用" class="headerlink" title="时间日期类的运用"></a>时间日期类的运用</h2></li></ul></li></ul><ol><li>字符串转化为日期时间<code>LocalDate.parse(String date, DateTimeFormatter df)</code>第二个字段为可选字段，在字符串格式不是<code>yyyy-MM-dd</code>使用统一格式<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">import java.time.LocalDate;</span><br><span class="line">import java.time.format.DateTimeFormatter;</span><br><span class="line"></span><br><span class="line">public class DateTest8 &#123;</span><br><span class="line"></span><br><span class="line">  public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">    String date &#x3D; &quot;2021-01-27&quot;;</span><br><span class="line">    &#x2F;&#x2F; 把字符串转化位 LocalDate 对象，并得到字符串匹配的时间</span><br><span class="line">    LocalDate date2 &#x3D; LocalDate.parse(date);</span><br><span class="line">    &#x2F;&#x2F; 打印出日期</span><br><span class="line">    System.out.println(date2.toString());</span><br><span class="line">    </span><br><span class="line">    date &#x3D; &quot;2021&#x2F;01&#x2F;27&quot;;</span><br><span class="line">    DateTimeFormatter df &#x3D; DateTimeFormatter.ofPattern(&quot;yyyy&#x2F;MM&#x2F;dd&quot;);</span><br><span class="line">    &#x2F;&#x2F; 把字符串转化位 LocalDate 对象，并得到字符串匹配的日期</span><br><span class="line">    LocalDate date2 &#x3D; LocalDate.parse(date,df);</span><br><span class="line">    &#x2F;&#x2F; 打印出日期</span><br><span class="line">    System.out.println(date2.toString());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>时间日期的计算(eg. <code>plusDays(int days)</code> <code>days</code>为天数)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">import java.time.LocalDate;</span><br><span class="line"></span><br><span class="line">public class DateTest10 &#123;</span><br><span class="line"></span><br><span class="line">  public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">    LocalDate now &#x3D; LocalDate.now();</span><br><span class="line">    System.out.println(&quot;当前：&quot; + now.toString());</span><br><span class="line"></span><br><span class="line">    System.out.println(&quot;加法运算&quot;);</span><br><span class="line">    System.out.println(&quot;加1天：&quot; + now.plusDays(1));</span><br><span class="line">    System.out.println(&quot;加1周：&quot; + now.plusWeeks(1));</span><br><span class="line">    System.out.println(&quot;加1月：&quot; + now.plusMonths(1));</span><br><span class="line">    System.out.println(&quot;加1年：&quot; + now.plusYears(1));</span><br><span class="line"></span><br><span class="line">    System.out.println(&quot;减法运算&quot;);</span><br><span class="line">    System.out.println(&quot;减1天：&quot; + now.minusDays(1));</span><br><span class="line">    System.out.println(&quot;减1周：&quot; + now.minusWeeks(1));</span><br><span class="line">    System.out.println(&quot;减1月：&quot; + now.minusMonths(1));</span><br><span class="line">    System.out.println(&quot;减1年：&quot; + now.minusYears(1));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>两个日期时间的判断<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">import java.time.LocalDate;</span><br><span class="line"></span><br><span class="line">public class DateTest11 &#123;</span><br><span class="line"></span><br><span class="line">  public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">    LocalDate now &#x3D; LocalDate.now();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 可以对两个 LocalDateTime 进行比较，</span><br><span class="line">    &#x2F;&#x2F; 可以判断一个日期是否在另一个日期之前或之后，</span><br><span class="line">    &#x2F;&#x2F; 或者判断两个日期是否是同年同月同日。</span><br><span class="line"></span><br><span class="line">    boolean isBefore &#x3D; now.minusDays(1).isBefore(LocalDate.now());</span><br><span class="line"></span><br><span class="line">    System.out.println(&quot;是否在当天之前：&quot; + isBefore);</span><br><span class="line"></span><br><span class="line">    boolean isAfter &#x3D; now.plusDays(1).isAfter(LocalDate.now());</span><br><span class="line">    System.out.println(&quot;是否在当天之后：&quot; + isAfter);</span><br><span class="line">    &#x2F;&#x2F; 判断是否是当天</span><br><span class="line">    boolean sameDate &#x3D; now.isEqual(LocalDate.now());</span><br><span class="line">    System.out.println(&quot;是否在当天：&quot; + sameDate);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;字符串&quot;&gt;&lt;a href=&quot;#字符串&quot; class=&quot;headerlink&quot; title=&quot;字符串&quot;&gt;&lt;/a&gt;字符串&lt;/h1&gt;&lt;h2 id=&quot;字符串的常用方法&quot;&gt;&lt;a href=&quot;#字符串的常用方法&quot; class=&quot;headerlink&quot; title=&quot;字符串的常</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>动态规划（二）</title>
    <link href="https://sruomerlin.github.io/2021/01/18/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%88%E4%BA%8C%EF%BC%89/index.html"/>
    <id>https://sruomerlin.github.io/2021/01/18/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%88%E4%BA%8C%EF%BC%89/index.html</id>
    <published>2021-01-18T10:22:19.000Z</published>
    <updated>2021-01-18T10:23:13.952Z</updated>
    
    <content type="html"><![CDATA[<h3 id="打家劫舍（一）"><a href="#打家劫舍（一）" class="headerlink" title="打家劫舍（一）"></a>打家劫舍（一）</h3><h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><ul><li>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，<strong>如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。</strong></li><li>给定一个代表每个房屋存放金额的非负整数数组，计算你 <strong>不触动警报装置的情况下</strong> ，一夜之内能够偷窃到的<strong>最高</strong>金额。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">示例1：</span><br><span class="line">输入：[1,2,3,1]</span><br><span class="line">输出：4</span><br><span class="line">解释：偷窃 1 号房屋 (金额 &#x3D; 1) ，然后偷窃 3 号房屋 (金额 &#x3D; 3)。 偷窃到的最高金额 &#x3D; 1 + 3 &#x3D; 4 。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">示例2：</span><br><span class="line">输入：[2,7,9,3,1]</span><br><span class="line">输出：12</span><br><span class="line">解释：偷窃 1 号房屋 (金额 &#x3D; 2), 偷窃 3 号房屋 (金额 &#x3D; 9)，接着偷窃 5 号房屋 (金额 &#x3D; 1)。</span><br><span class="line">偷窃到的最高金额 &#x3D; 2 + 9 + 1 &#x3D; 12 。</span><br></pre></td></tr></table></figure><h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4></li></ul><p><strong>状态转移方程</strong></p><ul><li>假设一排房屋rooms（房间数&gt;2），从最右侧开始考虑，对于第i+1间房屋rooms[i]只有两种状态：<ol><li>偷窃：最近的下一间可偷窃的房间就是[i-2]，已获得金额rooms[i]<ul><li>最终获得金额：f(i-2) + rooms[i] </li></ul></li><li>不偷窃：最近的下一间可偷窃的房间就是[i-1]，已获得金额0<ul><li>最终获得金额：f(i-1) + 0 </li></ul></li></ol></li><li>所以最终能得到的最高金额就是：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">result &#x3D; Max((f(i-2) + rooms[i]),f(i-1))</span><br></pre></td></tr></table></figure></li></ul><p><strong>考虑边界值</strong></p><ul><li>房屋数为0： result = 0;</li><li>房屋数为1： result = rooms[0];</li></ul><p><strong>输出</strong></p><ul><li>判断输出是否为最终状态；</li></ul><p><strong>代码</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line"></span><br><span class="line">public static HashMap&lt;Integer, Integer&gt; cache &#x3D; new HashMap&lt;&gt;();</span><br><span class="line">public static int rob(int[] rooms) &#123;</span><br><span class="line">cache.clear();</span><br><span class="line">return fCore(rooms, rooms.length - 1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static int fCore(int[] rooms, int index) &#123;</span><br><span class="line">  if (index &lt; 0) &#123;</span><br><span class="line">    return 0;</span><br><span class="line">  &#125;</span><br><span class="line">  if (index &#x3D;&#x3D; 0) &#123;</span><br><span class="line">    return rooms[0];</span><br><span class="line">  &#125;</span><br><span class="line">  if (cache.containsKey(index)) &#123;</span><br><span class="line">    return cache.get(index);</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  int count &#x3D; Math.max(fCore(rooms, index - 1), fCore(rooms, index - 2) + rooms[index]);</span><br><span class="line">  cache.put(index, count);</span><br><span class="line">  return count;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="打家劫舍（二）"><a href="#打家劫舍（二）" class="headerlink" title="打家劫舍（二）"></a>打家劫舍（二）</h3><h4 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h4><ul><li>你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都 围成一圈， 这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警 。</li><li>给定一个代表每个房屋存放金额的非负整数数组，计算你在不触动警报装置的情况下 ，能够偷窃到的最高金额。</li></ul><h4 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h4><ul><li>状态转移方程和基本思路同打家劫舍（一），</li><li>环状排列意味着第一个房子和最后一个房子中只能选择一个偷窃，因此可以把此环状排列房间问题约化为两个单排排列房间子问题：<ol><li>在不偷窃第一个房子的情况下（rooms[1 ~ n]），最大金额是P1;</li><li>在不偷窃最后一个房子的情况下（rooms[0 ~ (n-1)]），最大金额是P2。</li></ol></li><li>比较两者较大值max(p1, p2) </li></ul><p><strong>代码</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public static HashMap&lt;Integer, Integer&gt; cache &#x3D; new HashMap&lt;&gt;();</span><br><span class="line">    public int rob(int[] nums) &#123;</span><br><span class="line">        if(nums.length &#x3D;&#x3D; 1) return nums[0];</span><br><span class="line">        cache.clear();</span><br><span class="line">        int max1 &#x3D; myRob(Arrays.copyOfRange(nums, 0, nums.length - 1), nums.length-2);</span><br><span class="line">        cache.clear();</span><br><span class="line">        int max2 &#x3D; myRob(Arrays.copyOfRange(nums, 1, nums.length), nums.length-2);</span><br><span class="line">        return Math.max(max1, max2);</span><br><span class="line">    &#125;</span><br><span class="line">    private int myRob(int[] rooms, int index) &#123;</span><br><span class="line">        if (index &lt; 0) &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    if (index &#x3D;&#x3D; 0) &#123;</span><br><span class="line">        return rooms[0];</span><br><span class="line">    &#125;</span><br><span class="line">    if (cache.containsKey(index)) &#123;</span><br><span class="line">        return cache.get(index);</span><br><span class="line">    &#125;</span><br><span class="line">    int count &#x3D; Math.max( myRob(rooms, index - 1),  myRob(rooms, index - 2) + rooms[index]);</span><br><span class="line">    cache.put(index, count);</span><br><span class="line">    return count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;打家劫舍（一）&quot;&gt;&lt;a href=&quot;#打家劫舍（一）&quot; class=&quot;headerlink&quot; title=&quot;打家劫舍（一）&quot;&gt;&lt;/a&gt;打家劫舍（一）&lt;/h3&gt;&lt;h4 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>动态规划（一）</title>
    <link href="https://sruomerlin.github.io/2021/01/18/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%88%E4%B8%80%EF%BC%89/index.html"/>
    <id>https://sruomerlin.github.io/2021/01/18/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%88%E4%B8%80%EF%BC%89/index.html</id>
    <published>2021-01-18T07:06:01.000Z</published>
    <updated>2021-01-18T10:25:16.727Z</updated>
    
    <content type="html"><![CDATA[<h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h3><p>Those who do not remember the past are condemned to repeat it.</p><h4 id="理论"><a href="#理论" class="headerlink" title="理论"></a>理论</h4><ul><li>特点<ul><li>重复子问题：需要记录之前的计算结果；</li><li>最优子结构：不同规模之间的关系；</li><li>后无效性：只记录阶段结果而不关心这个结果是怎么来的；</li></ul></li><li>思路方向<ul><li>自顶向下：递归+记忆化；</li><li>自底向上：递推求解。</li></ul></li><li>状态转移方程<ul><li>将当前问题分解为几个小问题，这些小问题的最优解构成当前问题的最优解；  </li></ul></li><li>初始化</li><li>输出<ul><li>有时题目的解并不是最后一个状态</li></ul></li><li>考虑是否有可优化空间</li></ul><h4 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h4><h5 id="最长回文子串"><a href="#最长回文子串" class="headerlink" title="最长回文子串"></a>最长回文子串</h5><p>题目：<br>给你一个字符串 s，找到 s 中最长的回文子串。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：s &#x3D; &quot;babad&quot;</span><br><span class="line">输出：&quot;bab&quot;</span><br><span class="line">解释：&quot;aba&quot; 同样是符合题意的答案。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">示例 2：</span><br><span class="line">输入：s &#x3D; &quot;accacc&quot;</span><br><span class="line">输出：&quot;ccacc&quot;</span><br></pre></td></tr></table></figure><p>解题思路：</p><p><strong>状态转移方程</strong></p><ul><li>对于一个长度大于2的子串而言，如果他是回文串，那么它的首尾字符相同且去掉首尾两个字符，它任然是个回文串。</li><li>使用f(i, j)表示字符串s从第i个字符到第j个字符所组成的字符串 ，f(i, j)是回文串等价 于 f(i + 1, j - 1)是回文串且s[i] 和 s[j]相等。 根据这样的思路可以得出他的状态转移方程：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f(i,j) &#x3D; f(i + 1, j - 1) ∧ (s[i]&#x3D;&#x3D; s[j])</span><br></pre></td></tr></table></figure></li></ul><p><strong>初始化</strong></p><ul><li>对于长度大于3的状态可以使用状态转移方程，对于长度为1的字符串，它肯定是一个回文串；对于长度为2的字符串，当两个字符相同即s[i] = s[i+1]时，它是一个回文串，所以可得出初始化：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">f(i, i) &#x3D; true</span><br><span class="line"></span><br><span class="line">f(i, i+1) &#x3D; (s[i] &#x3D;&#x3D; s[i + 1])</span><br></pre></td></tr></table></figure></li></ul><p><strong>思考输出</strong></p><ul><li>我们需要求出的结果是最长回文串，是整个计算过程中的某一个状态，并不一定是是递归到最后一层所得出的结果。</li><li>设置maxLength = 0， 每当计算出一个状态且子串长度大于maxLength时更新maxLength的值并记录子串。</li></ul><p><strong>代码</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public String longestPalindrome(String s) &#123;</span><br><span class="line">    int maxLength &#x3D; 0;</span><br><span class="line">    String result &#x3D; &quot;&quot;;</span><br><span class="line">    boolean[][] dp &#x3D; new boolean[s.length()][s.length()];</span><br><span class="line">    for (int j &#x3D; 0; j &lt; s.length(); ++j) &#123;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; j + 1; ++i) &#123;</span><br><span class="line">            if (i &#x3D;&#x3D; j) &#123;</span><br><span class="line">                dp[i][j] &#x3D; true;</span><br><span class="line">            &#125; else if (j - i &#x3D;&#x3D; 1) &#123;</span><br><span class="line">                dp[i][j] &#x3D; (s.charAt(i) &#x3D;&#x3D; s.charAt(j));</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                dp[i][j] &#x3D; dp[i + 1][j - 1] &amp;&amp; (s.charAt(i) &#x3D;&#x3D; s.charAt(j));</span><br><span class="line">            &#125;</span><br><span class="line">            if (dp[i][j] &amp;&amp; j - i + 1 &gt; maxLength) &#123;</span><br><span class="line">                maxLength &#x3D; j - i + 1;</span><br><span class="line">                result &#x3D; s.substring(i, j + 1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong>：二维 dp 问题，一个状态得用二维有序数对表示。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">时间复杂度：O(N^&#123;2&#125;)</span><br><span class="line"></span><br><span class="line">空间复杂度：O(N^&#123;2&#125;)</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;动态规划&quot;&gt;&lt;a href=&quot;#动态规划&quot; class=&quot;headerlink&quot; title=&quot;动态规划&quot;&gt;&lt;/a&gt;动态规划&lt;/h3&gt;&lt;p&gt;Those who do not remember the past are condemned to repeat it.</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>learn-hexo</title>
    <link href="https://sruomerlin.github.io/2021/01/13/learn-hexo/index.html"/>
    <id>https://sruomerlin.github.io/2021/01/13/learn-hexo/index.html</id>
    <published>2021-01-13T09:57:23.000Z</published>
    <updated>2021-01-13T09:57:23.352Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://sruomerlin.github.io/2021/01/13/hello-world/index.html"/>
    <id>https://sruomerlin.github.io/2021/01/13/hello-world/index.html</id>
    <published>2021-01-13T02:58:07.817Z</published>
    <updated>2021-01-13T02:58:07.817Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</summary>
      
    
    
    
    
  </entry>
  
</feed>
