<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>如切如磋，如琢如磨</title>
  
  
  <link href="https://sruomerlin.github.io/atom.xml" rel="self"/>
  
  <link href="https://sruomerlin.github.io/"/>
  <updated>2021-01-18T07:06:52.872Z</updated>
  <id>https://sruomerlin.github.io/</id>
  
  <author>
    <name>SruoMerlin</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>动态规划（（一）</title>
    <link href="https://sruomerlin.github.io/2021/01/18/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%88%EF%BC%88%E4%B8%80%EF%BC%89/index.html"/>
    <id>https://sruomerlin.github.io/2021/01/18/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%88%EF%BC%88%E4%B8%80%EF%BC%89/index.html</id>
    <published>2021-01-18T07:06:01.000Z</published>
    <updated>2021-01-18T07:06:52.872Z</updated>
    
    <content type="html"><![CDATA[<h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h3><p>Those who do not remember the past are condemned to repeat it.</p><h4 id="理论"><a href="#理论" class="headerlink" title="理论"></a>理论</h4><ul><li>特点<ul><li>重复子问题：需要记录之前的计算结果；</li><li>最优子结构：不同规模之间的关系；</li><li>后无效性：只记录阶段结果而不关心这个结果是怎么来的；</li></ul></li><li>思路方向<ul><li>自顶向下：递归+记忆化；</li><li>自底向上：递推求解。</li></ul></li><li>状态转移方程<ul><li>将当前问题分解为几个小问题，这些小问题的最优解构成当前问题的最优解；  </li></ul></li><li>初始化</li><li>输出<ul><li>有时题目的解并不是最后一个状态</li></ul></li><li>考虑是否有可优化空间</li></ul><h4 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h4><h5 id="最长回文子串"><a href="#最长回文子串" class="headerlink" title="最长回文子串"></a>最长回文子串</h5><p>题目：<br>给你一个字符串 s，找到 s 中最长的回文子串。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：s &#x3D; &quot;babad&quot;</span><br><span class="line">输出：&quot;bab&quot;</span><br><span class="line">解释：&quot;aba&quot; 同样是符合题意的答案。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">示例 2：</span><br><span class="line">输入：s &#x3D; &quot;accacc&quot;</span><br><span class="line">输出：&quot;ccacc&quot;</span><br></pre></td></tr></table></figure><p>解题思路：</p><p><strong>状态转移方程</strong></p><ul><li>对于一个长度大于2的子串而言，如果他是回文串，那么它的首尾字符相同且去掉首尾两个字符，它任然是个回文串。</li><li>使用f(i, j)表示字符串s从第i个字符到第j个字符所组成的字符串 ，f(i, j)是回文串等价 于 f(i + 1, j - 1)是回文串且s[i] 和 s[j]相等。 根据这样的思路可以得出他的状态转移方程：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f(i,j) &#x3D; f(i + 1, j - 1) ∧ (s[i]&#x3D;&#x3D; s[j])</span><br></pre></td></tr></table></figure></li></ul><p><strong>初始化</strong></p><ul><li>对于长度大于3的状态可以使用状态转移方程，对于长度为1的字符串，它肯定是一个回文串；对于长度为2的字符串，当两个字符相同即s[i] = s[i+1]时，它是一个回文串，所以可得出初始化：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">f(i, i) &#x3D; true</span><br><span class="line"></span><br><span class="line">f(i, i+1) &#x3D; (s[i] &#x3D;&#x3D; s[i + 1])</span><br></pre></td></tr></table></figure></li></ul><p><strong>思考输出</strong></p><ul><li>我们需要求出的结果是最长回文串，是整个计算过程中的某一个状态，并不一定是是递归到最后一层所得出的结果。</li><li>设置maxLength = 0， 每当计算出一个状态且子串长度大于maxLength时更新maxLength的值并记录子串。</li></ul><p><strong>代码</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public String longestPalindrome(String s) &#123;</span><br><span class="line">    int maxLength &#x3D; 0;</span><br><span class="line">    String result &#x3D; &quot;&quot;;</span><br><span class="line">    boolean[][] dp &#x3D; new boolean[s.length()][s.length()];</span><br><span class="line">    for (int j &#x3D; 0; j &lt; s.length(); ++j) &#123;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; j + 1; ++i) &#123;</span><br><span class="line">            if (i &#x3D;&#x3D; j) &#123;</span><br><span class="line">                dp[i][j] &#x3D; true;</span><br><span class="line">            &#125; else if (j - i &#x3D;&#x3D; 1) &#123;</span><br><span class="line">                dp[i][j] &#x3D; (s.charAt(i) &#x3D;&#x3D; s.charAt(j));</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                dp[i][j] &#x3D; dp[i + 1][j - 1] &amp;&amp; (s.charAt(i) &#x3D;&#x3D; s.charAt(j));</span><br><span class="line">            &#125;</span><br><span class="line">            if (dp[i][j] &amp;&amp; j - i + 1 &gt; maxLength) &#123;</span><br><span class="line">                maxLength &#x3D; j - i + 1;</span><br><span class="line">                result &#x3D; s.substring(i, j + 1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong>：二维 dp 问题，一个状态得用二维有序数对表示。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">时间复杂度：O(N^&#123;2&#125;)</span><br><span class="line"></span><br><span class="line">空间复杂度：O(N^&#123;2&#125;)</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;动态规划&quot;&gt;&lt;a href=&quot;#动态规划&quot; class=&quot;headerlink&quot; title=&quot;动态规划&quot;&gt;&lt;/a&gt;动态规划&lt;/h3&gt;&lt;p&gt;Those who do not remember the past are condemned to repeat it.</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>learn-hexo</title>
    <link href="https://sruomerlin.github.io/2021/01/13/learn-hexo/index.html"/>
    <id>https://sruomerlin.github.io/2021/01/13/learn-hexo/index.html</id>
    <published>2021-01-13T09:57:23.000Z</published>
    <updated>2021-01-13T09:57:23.352Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://sruomerlin.github.io/2021/01/13/hello-world/index.html"/>
    <id>https://sruomerlin.github.io/2021/01/13/hello-world/index.html</id>
    <published>2021-01-13T02:58:07.817Z</published>
    <updated>2021-01-13T02:58:07.817Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</summary>
      
    
    
    
    
  </entry>
  
</feed>
